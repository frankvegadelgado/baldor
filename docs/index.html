<html>
  <head>
    <title>BALDOR</title>
    <style>
      body {
        background-color: black;
        color: white;
      }
      code:not(.language-diff) {
        background-color: white;
        color: black;
        display: inline-block;
      }
      code.language-diff {
        background-color: while;
        color: green;
      }
    </style>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js"],
        "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
        TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
        messageStyle: "none"
      });
    </script>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"
    ></script>
  </head>
  <body>
    <h1>Baldor: Minimum Dominating Set Solver</h1>
    <p>
      <img
        src="baldor.jpg"
        alt="Honoring the Memory of Aurelio Angel Baldor de la Vega (Cuban mathematician, educator and lawyer)"
      />
    </p>
    <p>
      This work builds upon
      <a
        href="https://www.researchgate.net/publication/389519333_New_Insights_and_Developments_on_the_Dominating_Set_Problem"
        >New Insights and Developments on the Dominating Set Problem</a
      >.
    </p>
    <hr />
    <h1>Overview of the Minimum Dominating Set (MDS)</h1>
    <h2>Definition:</h2>
    <p>
      A <strong>dominating set</strong> in a graph $G = (V, E)$ is a subset $D
      \subseteq V$ such that every vertex not in $D$ is adjacent to at least one
      vertex in $D$. The <strong>minimum dominating set (MDS)</strong> is the
      smallest possible dominating set in terms of the number of vertices.
    </p>
    <h2>Key Concepts:</h2>
    <ol>
      <li>
        <p><strong>Graph Representation</strong>:</p>
        <ul>
          <li>$V$: Set of vertices.</li>
          <li>$E$: Set of edges connecting the vertices.</li>
        </ul>
      </li>
      <li>
        <p><strong>Dominating Set</strong>:</p>
        <ul>
          <li>
            A set $D$ where for every vertex $v \in V$, either $v \in D$ or $v$
            is adjacent to some vertex in $D$.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Minimum Dominating Set</strong>:</p>
        <ul>
          <li>
            The dominating set with the smallest cardinality (i.e., the fewest
            number of vertices).
          </li>
        </ul>
      </li>
    </ol>
    <h2>Applications:</h2>
    <ul>
      <li>
        <strong>Network Design</strong>: Ensuring coverage in wireless sensor
        networks.
      </li>
      <li><strong>Social Networks</strong>: Identifying influential nodes.</li>
      <li>
        <strong>Game Theory</strong>: Strategies in certain types of games.
      </li>
      <li>
        <strong>Biology</strong>: Modeling protein-protein interaction networks.
      </li>
    </ul>
    <h2>Computational Complexity:</h2>
    <ul>
      <li>
        <strong>NP-Hard</strong>: Finding the minimum dominating set is
        computationally intensive for large graphs.
      </li>
      <li>
        <strong>Approximation Algorithms</strong>: Used to find near-optimal
        solutions in polynomial time.
      </li>
    </ul>
    <h2>Algorithms:</h2>
    <ol>
      <li>
        <p><strong>Greedy Algorithm</strong>:</p>
        <ul>
          <li>
            Iteratively selects the vertex that covers the most uncovered
            vertices.
          </li>
          <li>Provides a logarithmic approximation ratio.</li>
        </ul>
      </li>
      <li>
        <p><strong>Integer Linear Programming (ILP)</strong>:</p>
        <ul>
          <li>Formulates the problem as an optimization problem.</li>
          <li>
            Solvable using ILP solvers for exact solutions, though
            computationally expensive.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Heuristics and Metaheuristics</strong>:</p>
        <ul>
          <li>
            Genetic algorithms, simulated annealing, etc., for large-scale
            problems.
          </li>
        </ul>
      </li>
    </ol>
    <h2>Challenges:</h2>
    <ul>
      <li>
        <strong>Scalability</strong>: Exact algorithms are infeasible for very
        large graphs.
      </li>
      <li>
        <strong>Dynamic Graphs</strong>: Maintaining a minimum dominating set in
        graphs that change over time.
      </li>
    </ul>
    <h2>Research Directions:</h2>
    <ul>
      <li>
        <strong>Parallel Algorithms</strong>: Leveraging multi-core processors
        and distributed computing.
      </li>
      <li>
        <strong>Machine Learning</strong>: Using learning-based approaches to
        predict dominating sets.
      </li>
      <li>
        <strong>Hybrid Methods</strong>: Combining exact and heuristic methods
        for better performance.
      </li>
    </ul>
    <h2>Conclusion:</h2>
    <p>
      The minimum dominating set problem is a fundamental issue in graph theory
      with wide-ranging applications. While it is computationally challenging,
      various algorithms and heuristics provide practical solutions for
      different scenarios. Ongoing research continues to improve the efficiency
      and applicability of these methods.
    </p>
    <hr />
    <h2>Problem Statement</h2>
    <p>Input: A Boolean Adjacency Matrix $M$.</p>
    <p>Answer: Find a Minimum Dominating Set.</p>
    <h3>Example Instance: 5 x 5 matrix</h3>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>c1</th>
          <th>c2</th>
          <th>c3</th>
          <th>c4</th>
          <th>c5</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>r1</strong></td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <td><strong>r2</strong></td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
        </tr>
        <tr>
          <td><strong>r3</strong></td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <td><strong>r4</strong></td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <td><strong>r5</strong></td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
        </tr>
      </tbody>
    </table>
    <p>
      The input for undirected graph is typically provided in
      <a href="http://dimacs.rutgers.edu/Challenges">DIMACS</a> format. In this
      way, the previous adjacency matrix is represented in a text file using the
      following string representation:
    </p>
    <pre><code>p edge 5 4
e 1 3
e 1 5
e 2 4
e 3 5
</code></pre>
    <p>
      This represents a 5x5 matrix in DIMACS format such that each edge $(v,w)$
      appears exactly once in the input file and is not repeated as $(w,v)$. In
      this format, every edge appears in the form of
    </p>
    <pre><code>e W V
</code></pre>
    <p>
      where the fields W and V specify the endpoints of the edge while the
      lower-case character <code>e</code> signifies that this is an edge
      descriptor line.
    </p>
    <p><em>Example Solution:</em></p>
    <p>
      Dominating Set Found <code>1, 2</code>: Nodes <code>1</code> and
      <code>2</code> constitute an optimal solution.
    </p>
    <hr />
    <h1>Overview of the Dominating Set Algorithm</h1>
    <h2>Algorithm Description</h2>
    <p>
      The algorithm computes an approximate Dominating Set for an undirected
      graph $G = (V, E)$ in polynomial time. It achieves a
      <strong>sublogarithmic-approximation ratio</strong>, meaning the size of
      the computed dominating set is at most sublogarithmic times the size of
      the optimal solution. The algorithm consists of the following steps:
    </p>
    <ol>
      <li>
        <p><strong>Remove Isolated Nodes</strong>:</p>
        <ul>
          <li>
            Isolated nodes (nodes with no edges) are removed because they must
            be included in any dominating set.
          </li>
          <li>
            If the graph becomes empty after this step, the algorithm returns an
            empty set.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Compute a Minimum Edge Cover</strong>:</p>
        <ul>
          <li>
            A minimum edge cover is a set of edges such that every vertex in the
            graph is incident to at least one edge in the cover.
          </li>
          <li>
            This step ensures that all vertices are &quot;covered&quot; by
            edges, which is crucial for constructing the dominating set.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Construct a Subgraph from the Edge Cover</strong>:</p>
        <ul>
          <li>
            A subgraph is created using the edges from the minimum edge cover.
          </li>
          <li>
            This subgraph is a forest (a collection of trees), as the minimum
            edge cover in a graph without isolated nodes is a union of disjoint
            stars or trees.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Find Dominating Sets for Connected Components</strong>:</p>
        <ul>
          <li>
            The subgraph is decomposed into connected components, each of which
            is a tree.
          </li>
          <li>
            For each tree component, an optimal dominating set is computed using
            a tree-based algorithm.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Combine Dominating Sets</strong>:</p>
        <ul>
          <li>
            The dominating sets for all connected components are combined into a
            single candidate dominating set.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Remove Redundant Vertices</strong>:</p>
        <ul>
          <li>
            Redundant vertices (vertices whose removal does not invalidate the
            dominating set) are removed to ensure minimality.
          </li>
        </ul>
      </li>
    </ol>
    <h2>Runtime Analysis</h2>
    <p>The runtime of the algorithm is dominated by the following steps:</p>
    <ol>
      <li>
        <p><strong>Remove Isolated Nodes</strong>:</p>
        <ul>
          <li>Complexity: $O(|V|)$.</li>
        </ul>
      </li>
      <li>
        <p><strong>Compute a Minimum Edge Cover</strong>:</p>
        <ul>
          <li>Complexity: $O(|V|^3)$.</li>
        </ul>
      </li>
      <li>
        <p><strong>Construct a Subgraph from the Edge Cover</strong>:</p>
        <ul>
          <li>Complexity: $O(|E|)$.</li>
        </ul>
      </li>
      <li>
        <p><strong>Find Dominating Sets for Connected Components</strong>:</p>
        <ul>
          <li>Complexity: $O(|V| + |E|)$.</li>
        </ul>
      </li>
      <li>
        <p><strong>Combine Dominating Sets</strong>:</p>
        <ul>
          <li>Complexity: $O(|V|)$.</li>
        </ul>
      </li>
      <li>
        <p><strong>Remove Redundant Vertices</strong>:</p>
        <ul>
          <li>Complexity: $O(|V| \cdot |E|)$.</li>
        </ul>
      </li>
    </ol>
    <h3>Overall Runtime</h3>
    <p>
      The overall runtime of the algorithm is: $$O\left(|V|^3 + |V| \cdot
      |E|\right)$$ which simplifies as $$O\left(|V|^3\right)$$ for
      <strong>dense</strong> and <strong>sparse</strong> graphs.
    </p>
    <h2>Key Features</h2>
    <ul>
      <li>
        <strong>Approximation Ratio</strong>: The algorithm achieves a
        <strong>sublogarithmic-approximation ratio</strong>, meaning the size of
        the computed dominating set is at most sublogarithmic times the size of
        the optimal solution.
      </li>
      <li>
        <strong>Efficiency</strong>: The algorithm runs in polynomial time,
        making it suitable for large-scale graphs.
      </li>
      <li>
        <strong>Theoretical Guarantees</strong>: The correctness and
        approximation ratio are rigorously proven.
      </li>
    </ul>
    <h2>Applications</h2>
    <p>The algorithm is applicable in various domains, including:</p>
    <ul>
      <li>Network design and optimization.</li>
      <li>Social network analysis.</li>
      <li>Resource allocation in distributed systems.</li>
    </ul>
    <hr />
    <h1>Compile and Environment</h1>
    <h2>Prerequisites</h2>
    <ul>
      <li>Python ≥ 3.10</li>
    </ul>
    <h2>Installation</h2>
    <pre><code class="language-bash">pip install baldor
</code></pre>
    <h2>Execution</h2>
    <ol>
      <li>
        <p>Clone the repository:</p>
        <pre><code class="language-bash">git clone https://github.com/frankvegadelgado/baldor.git
cd baldor
</code></pre>
      </li>
      <li>
        <p>Run the script:</p>
        <pre><code class="language-bash">solve -i ./benchmarks/testMatrix1
</code></pre>
        <p>
          utilizing the <code>solve</code> command provided by Baldor's Library
          to execute the Boolean adjacency matrix
          <code>baldor\benchmarks\testMatrix1</code>. The file
          <code>testMatrix1</code> represents the example described herein. We
          also support <code>.xz</code>, <code>.lzma</code>, <code>.bz2</code>,
          and <code>.bzip2</code> compressed text files.
        </p>
        <p><strong>Example Output:</strong></p>
        <pre><code>testMatrix1: Dominating Set Found 1, 2
</code></pre>
        <p>This indicates nodes <code>1, 2</code> form a Dominating Set.</p>
      </li>
    </ol>
    <hr />
    <h2>Dominating Set Size</h2>
    <p>
      Use the <code>-c</code> flag to count the nodes in the Dominating Set:
    </p>
    <pre><code class="language-bash">solve -i ./benchmarks/testMatrix2 -c
</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code>testMatrix2: Dominating Set Size 2
</code></pre>
    <hr />
    <h1>Command Options</h1>
    <p>Display help and options:</p>
    <pre><code class="language-bash">solve -h
</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code class="language-bash">usage: solve [-h] -i INPUTFILE [-a] [-b] [-c] [-v] [-l] [--version]

Estimating the Minimum Dominating Set with a sublogarithmic-approximation ratio encoded for undirected graph in DIMACS format.

options:
  -h, --help            show this help message and exit
  -i INPUTFILE, --inputFile INPUTFILE
                        input file path
  -a, --approximation   enable comparison with another polynomial-time approximation approach within a logarithmic factor
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the Dominating Set
  -v, --verbose         anable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <hr />
    <h1>Batch Execution</h1>
    <p>
      Batch execution allows you to solve multiple graphs within a directory
      consecutively.
    </p>
    <p>
      To view available command-line options for the
      <code>batch_solve</code> command, use the following in your terminal or
      command prompt:
    </p>
    <pre><code class="language-bash">batch_solve -h
</code></pre>
    <p>This will display the following help information:</p>
    <pre><code class="language-bash">usage: batch_solve [-h] -i INPUTDIRECTORY [-a] [-b] [-c] [-v] [-l] [--version]

Estimating the Minimum Dominating Set with a sublogarithmic-approximation ratio for all undirected graphs encoded in DIMACS format and stored in a directory.

options:
  -h, --help            show this help message and exit
  -i INPUTDIRECTORY, --inputDirectory INPUTDIRECTORY
                        Input directory path
  -a, --approximation   enable comparison with another polynomial-time approximation approach within a logarithmic factor
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the Dominating Set
  -v, --verbose         anable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <hr />
    <h1>Testing Application</h1>
    <p>
      A command-line utility named <code>test_solve</code> is provided for
      evaluating the Algorithm using randomly generated, large sparse matrices.
      It supports the following options:
    </p>
    <pre><code class="language-bash">usage: test_solve [-h] -d DIMENSION [-n NUM_TESTS] [-s SPARSITY] [-a] [-b] [-c] [-w] [-v] [-l] [--version]

The Baldor Testing Application using randomly generated, large sparse matrices.

options:
  -h, --help            show this help message and exit
  -d DIMENSION, --dimension DIMENSION
                        an integer specifying the dimensions of the square matrices
  -n NUM_TESTS, --num_tests NUM_TESTS
                        an integer specifying the number of tests to run
  -s SPARSITY, --sparsity SPARSITY
                        sparsity of the matrices (0.0 for dense, close to 1.0 for very sparse)
  -a, --approximation   enable comparison with another polynomial-time approximation approach within a logarithmic factor
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the Dominating Set
  -w, --write           write the generated random matrix to a file in the current directory
  -v, --verbose         anable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <hr />
    <h1>Code</h1>
    <ul>
      <li>Python implementation by <strong>Frank Vega</strong>.</li>
    </ul>
    <hr />
    <h1>Complexity</h1>
    <pre><code class="language-diff">+ We present a polynomial-time algorithm achieving a sublogarithmic-approximation factor for MDS, providing strong evidence that P = NP by efficiently solving a computationally hard problem with near-optimal solutions.
</code></pre>
    <hr />
    <h1>License</h1>
    <ul>
      <li>MIT License.</li>
    </ul>
  </body>
</html>
